import groovy.json.JsonSlurper
import sun.nio.fs.UnixPath

import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.stream.Collectors

apply plugin: 'kotlin'
apply plugin: 'application'
apply plugin: 'org.jetbrains.dokka'

dependencies {
    implementation group: 'jaxen', name: 'jaxen', version: '1.1.6'
    implementation group: 'org.dom4j', name: 'dom4j', version: '2.1.1'
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    testImplementation group: 'junit', name: 'junit', version: '4.12'
    testImplementation group: 'org.jetbrains.kotlin', name: 'kotlin-test-junit', version: '1.3.21'
}

dokka {
    outputFormat = 'html'
    outputDirectory = "$buildDir/javadoc"
}

sourceCompatibility = 11
mainClassName = ""

apply from: 'jcenter.gradle'

// --------------------------------------------------------------------------

def rustSrcDir = Paths.get("$projectDir/src/main/rust")
def rustPlatforms = [
        // for Windows
        "i686-pc-windows-gnu",
        "x86_64-pc-windows-gnu",
//        // for Mac OSX
//        "i686-apple-darwin",
//        "x86_64-apple-darwin",
//        // for iOS
//        "armv7-apple-ios",
//        "aarch64-apple-ios",
        // for Linux
        "i686-unknown-linux-gnu",
        "x86_64-unknown-linux-gnu",
        // for Linux(arm)
        "arm-unknown-linux-gnueabihf",
        "aarch64-unknown-linux-gnu",
]

task("rustPlatformsInstall") << {
    new RustPlatform(rustSrcDir, rustPlatforms).install()
}

task("rustClean") << {
    new RustPlatform(rustSrcDir, rustPlatforms).clean()
}

task("rustBuildDebug") << {
    new RustPlatform(rustSrcDir, rustPlatforms).build(RustPlatform.BuildMode.Debug)
}

task("rustBuildRelease") << {
    new RustPlatform(rustSrcDir, rustPlatforms).build(RustPlatform.BuildMode.Release)
}

task("rustDeployDebug") << {
    new RustPlatform(rustSrcDir, rustPlatforms).deploy(RustPlatform.BuildMode.Debug)
}

task("rustDeployRelease") << {
    new RustPlatform(rustSrcDir, rustPlatforms).deploy(RustPlatform.BuildMode.Release)
}

tasks["rustBuildDebug"].dependsOn("rustPlatformsInstall")
tasks["rustBuildRelease"].dependsOn("rustPlatformsInstall")
tasks["rustDeployDebug"].dependsOn("rustBuildDebug")
tasks["rustDeployRelease"].dependsOn("rustBuildRelease")

// --------------------------------------------------------------------------

// When building JNI for Android, set the "supportAndroid" flag to true.
// However, setup of Android NDK is necessary separately. You need to get the NDK archive from the developer site and extract it to any location.
// Developer site (NDK download page):
// https://developer.android.com/ndk/downloads/
def supportAndroid = true

if (supportAndroid) {
    // It is necessary to set the path which expanded the archive of NDK.
    def buildToolsDir = Paths.get(
            // For example, when using Windows
            // "C:\\android-ndk-r19c"
            // For example, when using Linux
            "/usr/local/android-ndk-r20/toolchains/llvm/prebuilt/linux-x86_64/bin/"
    )

    def rustAndroidPlatforms = [
            // for Android
            "i686-linux-android",
            "x86_64-linux-android",
            "armv7-linux-androideabi",
            "aarch64-linux-android",
    ]

    def toolchainPath = Paths.get(projectDir.toPath().toString(), "/toolchain.json")

    task("rustAndroidPlatformsInstall") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, buildToolsDir, toolchainPath).install()
    }

    task("rustBuildAndroidDebug") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, buildToolsDir, toolchainPath).build(RustPlatform.BuildMode.Debug)
    }

    task("rustBuildAndroidRelease") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, buildToolsDir, toolchainPath).build(RustPlatform.BuildMode.Release)
    }

    task("rustDeployAndroidDebug") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, buildToolsDir, toolchainPath).deploy(RustPlatform.BuildMode.Debug)
    }

    task("rustDeployAndroidRelease") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, buildToolsDir, toolchainPath).deploy(RustPlatform.BuildMode.Release)
    }

    tasks["rustBuildAndroidDebug"].dependsOn(["rustPlatformsInstall", "rustAndroidPlatformsInstall"])
    tasks["rustBuildAndroidRelease"].dependsOn(["rustPlatformsInstall", "rustAndroidPlatformsInstall"])
    tasks["rustDeployAndroidDebug"].dependsOn("rustBuildAndroidDebug")
    tasks["rustDeployAndroidRelease"].dependsOn("rustBuildAndroidRelease")
}

// --------------------------------------------------------------------------

class RustPlatform extends AbstractPlatform {
    protected def rustPlatforms = new ArrayList<String>()

    RustPlatform(Path buildTargetPath, List<String> platforms) {
        super(buildTargetPath)
        this.rustPlatforms.addAll(platforms)
    }

    def install() {
        rustPlatforms.forEach {
            run("rustup", "target", "install", it)
        }
        return this
    }

    def build(BuildMode mode) {
        rustPlatforms.forEach {
            if (isWindows() && !it.contains("windows")) {
                println("[$it] The build is running on Windows. Other than platforms for Windows are not supported.")
                return null
            }

            println("[$it] compile start.")
            run("cargo", "build", "--target", it, ((mode == BuildMode.Release) ? "--release" : ""))
            println("[$it] compile finish!")
        }
        return this
    }
    
    def deploy(BuildMode target) {
        rustPlatforms.forEach {
            def filename = it.contains("windows") ? "kanaria_jni.dll" : "libkanaria_jni.so"
            def src = Paths.get("$buildTargetPath/target/$it/${target == BuildMode.Debug ? "debug" : "release"}/$filename")
            if (!src.toFile().exists()) {
                throw new InvalidRustException("lib is not found.")
            }

            def dest = Paths.get("$buildTargetPath/../resources/com/kanaria/platforms/$it/")
            if (dest.toFile().exists()) {
                dest.deleteDir()
            }
            dest.toFile().mkdirs()

            Files.copy(src, Paths.get(dest.toString(), filename.replace(".so", "").replace(".dll", "")))
        }
    }

    def clean() {
        run("cargo", "clean")
    }

    enum BuildMode {
        Debug, Release
    }
}

class AndroidNdkPlatform extends RustPlatform {
    Path buildToolsDir = null
    Path manifestPath = null
    Object manifestJson = null;

    AndroidNdkPlatform(Path buildTargetPath, List<String> rustPlatforms, Path buildToolsDir, Path manifest) {
        super(buildTargetPath, rustPlatforms)
        this.buildToolsDir = buildToolsDir
        this.manifestPath = manifest;
    }

    @Override
    def build(BuildMode mode) {
        def bin = buildToolsDir.toString()

        rustPlatforms.forEach {
            if (isWindows() && !it.contains("windows")) {
                println("[$it] The build is running on Windows. Other than platforms for Windows are not supported.")
                return null
            }

            println("[$it] compile start.")

            putEnv(it, bin, "AR")
            putEnv(it, bin, "AS")
            putEnv(it, bin, "CC")
            putEnv(it, bin, "CXX")
            putEnv(it, bin, "LD")
            putEnv(it, bin, "RANLIB")
            putEnv(it, bin, "STRIP")

            run("cargo", "build", "--target", it, ((mode == BuildMode.Release) ? "--release" : ""))
            println("[$it] compile finish!")
        }
        return this
    }

    def putEnv(String platformName, String bin, String envName) {
        Object manifest = getManifest()
        if (manifest == null) {
            return
        }

        def platform = manifest[platformName]
        if (platform == null){
            return
        }

        def envValue = platform[envName]
        if (envValue == null){
            return
        }

        env.put(envName, bin + envValue.toString())
    }

    def getManifest() {
        if (this.manifestJson == null && this.manifestPath.toFile().exists()) {
            this.manifestJson = new JsonSlurper().parseText(this.manifestPath.toFile().text)
        }

        return this.manifestJson
    }
}

class AbstractPlatform {
    protected def buildTargetPath = Paths.get("")
    protected def env = new HashMap<String, String>()

    AbstractPlatform(Path buildTargetPath) {
        this.buildTargetPath = buildTargetPath
    }

    protected def run(String... command) {
        def outBuffer = new PrintBuffer([(Appendable) System.out])
        def errBuffer = new PrintBuffer([])

        def processBuilder = new ProcessBuilder(
                command.toList()
                        .stream()
                        .filter { !it.isEmpty() }
                        .collect(Collectors.toList())
        )
        processBuilder.environment().putAll(env)

        processBuilder
                .directory(buildTargetPath.toFile())
                .start()
                .waitForProcessOutput(outBuffer, errBuffer)

        def err = errBuffer.toString()
        if (err.contains("error:")) {
            throw new InvalidRustException(err)
        }
    }

    protected static def getFamily() {
        String os = System.getProperty("os.name")
        if (os == null)
            return ""
        else if (os.toLowerCase().startsWith("windows"))
            return "windows"
        else if (os.toLowerCase().startsWith("mac"))
            return "mac"
        else if (os.toLowerCase().startsWith("linux"))
            return "unix"
        return ""
    }

    protected static def isWindows() {
        getFamily() == "windows"
    }

    protected static def isLinux() {
        getFamily() == "linux"
    }

    protected static def isMac() {
        getFamily() == "mac"
    }

    protected static def getArch(String rustPlatformName) {
        rustPlatformName.split('-')[0]
    }

    private class PrintBuffer implements Appendable {
        private def buffer = new StringBuffer()
        private def appendable = new ArrayList<Appendable>()

        PrintBuffer(List<Appendable> appendableList) {
            appendable.add(buffer)
            appendable.addAll(appendableList)
        }

        @Override
        Appendable append(CharSequence csq) throws IOException {
            appendable.forEach {
                it.append(csq)
            }
            return this
        }

        @Override
        Appendable append(CharSequence csq, int start, int end) throws IOException {
            appendable.forEach {
                it.append(csq, start, end)
            }
            return this
        }

        @Override
        Appendable append(char c) throws IOException {
            appendable.forEach {
                it.append(c)
            }
            return this
        }

        @Override
        String toString() {
            return buffer.toString()
        }
    }
}

class InvalidRustException extends RuntimeException {
    InvalidRustException(String message) {
        super(message)
    }
}